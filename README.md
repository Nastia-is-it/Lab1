# Описание и алгоритм работы функций. #

## 1. Нужно вывести дробную часть числа ##
Нахожу остаток от дления на 1 (число целое), в результате чего целая часть откидывается и остаётся дробная
### <img width="424" height="159" alt="image" src="https://github.com/user-attachments/assets/f687086b-fc13-465d-9166-eea077db0351" />
Проверка работы: 
### <img width="405" height="59" alt="image" src="https://github.com/user-attachments/assets/42f787c7-aa8e-4bb5-9168-37c0acd36c44" />

## 2. Нужно преобразовать символ в число(цифру)
* Символ преобразую в строку
* Затем строку в число

### <img width="457" height="96" alt="image" src="https://github.com/user-attachments/assets/8e991333-2083-4d6a-95ef-f72a9a5d8cee" />

Проверка работы:
### <img width="588" height="62" alt="image" src="https://github.com/user-attachments/assets/b4eeef64-fbc5-45b9-a34f-967644dedb91" />

## Проверить число на двузначность: вернуть true, если число двузначное и false, если нет
* Введённое пользователем целое число преобразую в строку
* Делаю проверку: если длина этой строки равна 2, то возращаю true

Проверка работы:
### 1)
<img width="545" height="61" alt="image" src="https://github.com/user-attachments/assets/d6afaf7f-ecf0-4eaa-9faa-e350f9f1bcaf" />

### 2)
<img width="546" height="70" alt="image" src="https://github.com/user-attachments/assets/aa72ed10-9b9c-4ebc-b37a-e37f833a4979" />

## Проверить входит ли число в диапазон от a от b, при условии, что неизвестно какая граница больше, а какая меньше
* Проверяем условие a < b
* Если оно выполняется, то проверяем диапазон от a до b. Сравниваем искомое число с текущим, и когда найдётся возвращаю true
* Если нет, то проверяем диапазон от b до a, так же сравнивая искомое с текущим
* Если не нашлось, то возвращаю false

Проверка работы:
### 1)
<img width="304" height="126" alt="image" src="https://github.com/user-attachments/assets/845589f9-7624-4c6f-abb2-0cd9dbe3f283" />

### 2)
<img width="336" height="130" alt="image" src="https://github.com/user-attachments/assets/4034c44c-f8d8-43c7-9894-1c8dfcb87976" />

### 3)
<img width="310" height="130" alt="image" src="https://github.com/user-attachments/assets/1f39c8a2-8bed-4b1f-8e20-0d281514c98d" />

## Проверка на равенство трёх чисел. 
* Сравниваю числа между собой. Если a равно b И b равно c И a равно с, то возвращаю true
* Иначе false

Проверка работы:
### 1)
<img width="201" height="130" alt="image" src="https://github.com/user-attachments/assets/098412a8-5103-4c48-b4d7-2f2a0a4dfd81" />

### 2)
<img width="216" height="126" alt="image" src="https://github.com/user-attachments/assets/2adad78f-77ea-4ddc-81b2-c8966f3fc43f" />

### 3)
<img width="218" height="129" alt="image" src="https://github.com/user-attachments/assets/ee94500c-eaf6-47cb-a93d-d338c5fddbe0" />

## Найти модуль числа
* Если число отрицательное, то умножаю на -1 чтобы поменять знак и возвращаю
* Иначе просто возвращаю число

Проверка работы:
### 1) 
<img width="239" height="88" alt="image" src="https://github.com/user-attachments/assets/7244006c-b9b7-48ae-83b8-09875b37a86a" />

### 2)
<img width="236" height="93" alt="image" src="https://github.com/user-attachments/assets/2afe379a-b5ba-4b50-88df-48f1a4c7fa53" />

## Проверка числа (x): должно делится либо на 3, либо на 5, одновременно на 3 и 5 делится не может
* Если (x делится на 3 или x делится на 5) и x не делится на 15, тк число 15 включает в себя 3*5, то возвращаию true
* Иначе false

Проверка работы:
### 1)
<img width="221" height="94" alt="image" src="https://github.com/user-attachments/assets/1ae9b48b-652f-45f1-805e-01c8ed75def9" />

### 2)
<img width="220" height="83" alt="image" src="https://github.com/user-attachments/assets/a7b74653-79cc-435d-bf33-e8d265625ba6" />

### 3)
<img width="231" height="89" alt="image" src="https://github.com/user-attachments/assets/94009066-d679-471d-9a93-893e2694029c" />

### 4)
<img width="231" height="88" alt="image" src="https://github.com/user-attachments/assets/c9e6978b-17fd-4678-bb86-43a9b1df57d3" />

## Найти наибольшее число из трёх (x, y, z - введены пользователем)
* Найти максимальное между x и y:
  - Если x > y, то временная переменная t = x
  - Иначе t = y
* Сравнить полученное значение t с z:
  - Если t > z, вернуть t
  - Иначе вернуть z

Проверка работы:
### <img width="385" height="150" alt="image" src="https://github.com/user-attachments/assets/d6567877-5018-4a9b-87c9-bb1002d1a299" />


## Вернуть сумму чисел, но если она попадает в промежуток от 10 до 19, то вернуть 20
* Вычислить сумму c = x + y
* Проверить попадает ли сумма в специальный диапазон:
  - Если c находится в интервале от 10 до 19 включительно
  - Тогда вернуть фиксированное значение 20
  - Иначе вернуть фактическую сумму c

Проверка работы:
### 1)
<img width="207" height="95" alt="image" src="https://github.com/user-attachments/assets/45ff6e18-917a-45a6-8dbb-dfb044565296" />

### 2)
<img width="201" height="103" alt="image" src="https://github.com/user-attachments/assets/1d80d2c6-141d-420e-8c9a-cf404ec0310b" />


## Определить название недели по его номеру
* Использовать конструкцию switch-case для определения дня:
  * Если введено 1: вернуть "Понедельник"
  * Если введено 2: вернуть "Вторник" 
  * Если введено 3: вернуть "Среда"
  * Если введено 4: вернуть "Четверг"
  * Если введено 5: вернуть "Пятница"
  * Если введено 6: вернуть "Суббота"
  * Если введено 7: вернуть "Воскресенье"
  * По умолчанию: вернуть "Это не день недели"

Проверка работы:
### <img width="291" height="74" alt="image" src="https://github.com/user-attachments/assets/5c796e0c-6f30-42e6-bd50-032e8010e540" />


## Вернуть строку с числами от 0 до x
* Инициализировать пустую строку, в которой будет результат
* Использовать цикл for для генерации последовательности:
  - Начать с i = 0, увеличивать i на 1 каждый шаг, пока i <= x
  - На каждой итерации:
    * Преобразовать текущее число i в строку
    * Добавить полученную строку и пробел в результирующую строку
* Вернуть собранную строку с числами

Проверка работы:
### <img width="422" height="93" alt="image" src="https://github.com/user-attachments/assets/a3e4292d-56f0-4d95-b5f5-744cef98ddaa" />

## Вернуть строку с чётными числами от 0 до x
* Инициализировать пустую строку, в которой будет результат
* Использовать цикл for с шагом 2 для перебора четных чисел:
  - Начать с i = 0, увеличивать i на 2 каждый шаг, пока i <= x
  - На каждой итерации:
    * Преобразовать текущее четное число i в строку
    * Добавить полученную строку и пробел в результирующую строку
* Вернуть строку, содержащую все четные числа через пробел

Проверка работы:
### <img width="503" height="107" alt="image" src="https://github.com/user-attachments/assets/efcf8dc2-416f-4cf2-9b50-6407f40f4542" />

## Вернуть количество знаков в числе
* Создать счетчик цифр s = 0
* Использовать цикл while для последовательного деления числа:
  - Пока x больше 0:
    * Разделить x на 10 (отбросить последнюю цифру)
    * Увеличить счетчик s на 1
* Вернуть значение счетчика s (количество цифр)

Проверка работы:
### <img width="388" height="77" alt="image" src="https://github.com/user-attachments/assets/c851bd0e-0264-412a-9a28-c564105740be" />

## Нарисовать квадрат
* Использовать вложенные циклы для построения квадрата:
  - Внешний цикл по i от 0 до x-1 (строки)
  - Внутренний цикл по j от 0 до x-1 (столбцы)
    * На каждой итерации внутреннего цикла выводить символ "*"
  - После завершения внутреннего цикла переходить на новую строку

Проверка работы:
### 
## Нарисовать правый треугольник
* Использовать цикл для построения строк треугольника:
  - Для i от 1 до x (номер текущей строки):
    * Вывести (x - i) пробелов для выравнивания вправо
    * Вывести i звезд "*" для формирования треугольника
    * Перейти на новую строку

Проверка работы:

## Найти индекс первого вхождения числа x
* Пройти по всем элементам массива последовательно от начала до конца массива:
    * Если текущий элемент равен искомому числу x
    * Вернуть индекс i (первое найденное вхождение)
* Если цикл завершился без нахождения, вернуть -1

Проверка работы:
## Найти наибольшее по модулю число
* Инициализировать переменную max первым элементом массива
* Пройти по всем остальным элементам массива arr начиная с индекса 1:
    * Сравнить значения по модулю |arr[i]| и |max| (используя реализованную функцию)
    * Если |arr[i]| > |max|, обновить max = arr[i]
* Вернуть найденное максимальное по модулю значение

Проверка работы:

## Вернуть массив, содержащий массивы arr и ins в позиции pos
* Создать новый массив размером = длина arr + длина ins
* Скопировать элементы arr от индекса 0 до pos-1 в начало нового массива
* Скопировать все элементы массива ins в позицию pos нового массива
* Скопировать оставшиеся элементы arr от pos до конца после вставленного массива
* Вернуть полученный массив

Проверка работы:
## Инвертировать массив
* Создать новый массив такой же длины как исходный
* Пройти по всем индексам исходного массива:
  - Для каждого индекса i от 0 до конца:
    * Записать в newArr[i] элемент из arr[длина-1-i]
    * Таким образом первый элемент становится последним и наоборот
* Вернуть инвертированный массив

Проверка работы:
## Найти все индексы вхождения числа x
* Пройти по всем элементам массива и посчитать сколько раз встречается x
* Создать новый массив размером = количеству найденных вхождений
Использовать дополнительный индекс j:
    * Если arr[i] равен x, записать индекс i в newArr[j] и увеличить j
* Вернуть массив с индексами всех вхождений

Проверка работы:
